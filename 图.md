## 图
### 一、图的基本概念
- #### 图的定义
  ==图$G$==由==顶点集$V$==和==边集$E$==组成(G:Graph;V:Vertex;E:Edge)，记为$G = (V,E)$，其中$V(G)$表示图$G$中顶点的有限空集；$E(G)$表示图$G$中顶点之间的关系（边）集合。若$V = {v_{1},v_{2},\dots,v_{n}}$，则用==$|V|$==表示图$G$中==顶点的个数==，也称==图$G$的阶==，==$E = \{(u,v) \mid u\in V,v\in V\}$==，用==$|E|$==表示图$G$中==边的条数==。
  **注意：线性表可以是空表，树可以是空树，但图不可以是空，即==$V$一定是非空集==，一个图的边集可以是空集**
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251219104944340.png)
 - #### 无向图、有向图
   若$E$是==无向边==（简称边）的有限集合时，则图$G$为==无向图==。边是顶点的无序对，==记为$(v,w)$或$(w,v)$==，因为==$(v,w) = (w,v)$==，其中$v、w$是顶点。可以说顶点$w$和顶点$v$互为邻接点。边$(v,w)$依附于顶点$w$和$v$，或者说边$(v,w)$和顶点$v、w$相关联。
   <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251219111650219.png" alt=""></div>
 
   $$
\begin{array}{l} G_{2}=\left(V_{2}, E_{2}\right)\\ V_{2}=\{A, B, C, D, E\}\\ E_{2}=\{(A,B), (B,D), (B,E), (C,D), (C,E), (D,E)\} \end{array}
$$
   若$E$是==有向边==（也称==弧==）的有限集合时，则图$G$为==有向图==。弧是顶点的有序对，==记为$<v,w>$==，其中$v、w$是顶点，$v$称为==弧尾==，$w$称为==弧头==，$<v,w>$称为从顶点$v$到顶点$w$的弧，也称$v$邻接到$w$，或$w$邻接自$v$。==$<v,w>\ne<w,v>$==
   <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251219143042093.png" alt=""></div>

   $$
\begin{array}{l}
G_{1}=\left(V_{1}, E_{1}\right)\\ V_{1}=\{A, B, C, D, E\}\\ E_{1}=\{<A,B>, <A,C>, <A,D>, <A,E>, <B,A>, <B,C>,<B,E>,<C,D>\}
\end{array}
$$
- #### 简单图、多重图
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251219143814825.png)
- #### 图逻辑结构的应用
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251219144019405.png)
- #### 顶点的度、入度、出度
  对于==无向图==：
  ==顶点$v$的度==是指依附于该顶点的边的条数，记为$\mathrm{TD}(v)$。在具有$n$个顶点、$e$条边的无向图中
  $$
\sum_{i=1}^{n}\mathrm{TD}(v_{i}) = 2e
$$
  即无向图的全部顶点的度的和等于边数的2倍
  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251219145259733.png" alt=""></div>
  
  对于==有向图==：
  ==入度==是以顶点$v$为终点的有向边的数目，记为==$\mathrm{ID}(v)$==；
  ==出度==是以顶点$v$为起点的有向边的数目，记为==$\mathrm{OD}(v)$==。
  ==顶点$v$的度==等于其==入度和出度之和==，即$\mathrm{TD}(v)=\mathrm{ID}(v)+\mathrm{OD}(v)$。
  在具有$n$个顶点、$e$条边的有向图中
  $$
\sum_{i=1}^{n}\mathrm{ID}(v_{i})=\sum_{i=1}^{n}\mathrm{OD}(v_{i})=e
$$
  即有向图的入度等于出度等于e
  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251219150139003.png" alt=""></div>

- #### 顶点-顶点的关系描述
  - ==路径==——顶点$v_{p}$到顶点$v_{q}$之间的一条路径是指顶点序列，$v_{p},v_{i_{1}},v_{i_{2}},\dots,v_{i_{m}},v_{q}$
  - ==回路==——第一个顶点和最后一个顶点相同的路径称为回路或环
  - ==简单路径==——在路径序列中，顶点不重复出现的路径称为简单路径
  - ==简单回路==——除第一个顶点和最后一个顶点外，其余顶点不重复出现的回路称之为简单回路
  - ==路径长度==——路径上边的数目
  - ==点到点的距离==——从顶点$u$出发到顶点$v$的==最短路径==若存在，则==此路径的长度称为从$u$到$v$的距离==；若从$u$到$v$根本==不存在路径==，则记该距离为无穷（$\infty$）
  - ==无向图==中，若从顶点$v$到顶点$w$有路径存在，则称$v$和$w$是连通的
  - ==有向图==中，若从顶点$v$到顶点$w$和从顶点$w$到顶点$v$之间都有路径，则称这两个顶点是==强连通==的
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222092750101.png)
- #### 连通图、强连通图
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222094411020.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222094539268.png)
- #### 研究图的局部——子图
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222094703141.png)
- #### 连通分量
  ==无向图==中的==极大连通子图==称为==连通分量==，子图必须连通，且包含尽可能多的顶点和边
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222094933289.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222095049012.png)
- #### 强连通分量
  ==有向图==中的==极大强连通子图==称为有向图的==强连通分量==，子图必须强连通，同时保留尽可能多的边
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222095429357.png)
- #### 生成树
  ==连通图==（无向图）的==生成树==是==包含图中全部顶点的一个极小连通子图==，边尽可能的少，但要保持连通
  若图中顶点数为n，则它的生成树含有n-1条边。对生成树而言，若砍去它的一条边，则会变成==非连通图==，若加上一条边则会形成一个==回路==
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222095726179.png)
- #### 生成森林
  在==非连通图==中，==连通分量的生成树==构成了非连通图的==生成森林==
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222100315648.png)
- #### 边的权、带权图/网
  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222100444898.png" alt=""></div>
  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222101048163.png" alt=""></div>

  ==边的权==——在一个图中，每条边都可以标上具有某种含义的数值，该数值成为该边的==权值==
  ==带权图/网==——边上带有权值的图称为带权图，也称==网==
  ==带权路径长度==——当图是带权图时，一条==路径上所有边的权值之和==，称为该路径的带权路径长度
- #### 几种特殊形态的图
  ==无向完全图==——无向图中任意两个顶点之间都存在边
  若无向图的顶点数$|\mathrm{V}|=n$，则$|E|\in[0,C_{n}^2]=\left[0,\frac{n(n-1)}{2} \right]$
  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222101850726.png" alt=""></div>

  ==有向完全图==——有向图中任意两个顶点之间都存在方向相反的两条弧
  若有向图的顶点数$|\mathrm{V}|=n$，则$|E|\in[0,2C_{n}^2]=[0,n(n-1)]$
  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222102306521.png" alt=""></div>

  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222102517799.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222102637089.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222102706264.png)

  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222102738995.png" alt=""></div>


![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222103622052.png)
### 二、邻接矩阵法
- #### 图的存储——邻接矩阵法
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222150652629.png)
  ```c
  #define MaxVertexNum 100    //顶点数目的最大值
  typedef struct
  {
	  char Vex[MaxVertexNum];   //顶点表
	  int Edge[MaxVertexNum][MaxVertexNum];    //邻接矩阵，边表
	  int vexnum,arcnum;                       //图的当前顶点数和边数/弧数
  }MGraph;
  ```
  结点数为$n$的图$G=(V,E)$的邻接矩阵$A$是$n\times n$的。将$G$的顶点编号为$v_{1},v_{2},\dots,v_{n}$，则
  $$
\mathrm{A}[i][j]=\begin{cases}
1, & \text{若 }(v_i, v_j) \text{ 或 } <v_i, v_j> \text{ 是 } E(G) \text{ 中的边} \\
0, & \text{若 }(v_i, v_j) \text{ 或 } <v_i, v_j> \text{ 不是 } E(G) \text{ 中的边}
\end{cases}
$$
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222152105526.png)
- #### 邻接矩阵法存储带权图（网）
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222154419841.png)

  ```c
  #define MaxVertexNum 100                      //顶点数目的最大值
  #define INFINITY 最大的int值                   //宏定义常量“无穷”
  typedef char VertexType;                      //顶点的数据类型
  typedef int EdgeType;                         //带权图中边上权值的数据类型
  typedef struct
  {
	  VertexType Vex[MaxVertexNum];              //顶点
	  EdgeType Edge[MaxVertexNum][MaxVertexNum]; //边的权
	  int vexnum,arcnum;                         //图的当前顶点数和弧数
  }MGraph;
  ```
- #### 邻接矩阵法的性能分析
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222154633320.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222154724936.png)
- #### 邻接矩阵法的性质
  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222155535391.png" alt=""></div>

  设图$G$的邻接矩阵为$A$（矩阵元素为0/1），则$A^n$的元素$A^n[i][j]$等于由顶点$i$到顶点$j$的长度为$n$的路径的数目
  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222160446094.png" alt=""><br><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222161743748.png
" alt=""></div>

$$
\begin{align*} \mathrm{A}^{2}[1][4] &= \mathrm{a}_{1,1}\mathrm{a}_{1,4} + \mathrm{a}_{1,2}\mathrm{a}_{2,4} + \mathrm{a}_{1,3}\mathrm{a}_{3,4} + \mathrm{a}_{1,4}\mathrm{a}_{4,4} = 1 \\ \mathrm{A}^{2}[2][2] &= \mathrm{a}_{2,1}\mathrm{a}_{1,2} + \mathrm{a}_{2,2}\mathrm{a}_{2,2} + \mathrm{a}_{2,3}\mathrm{a}_{3,2} + \mathrm{a}_{2,4}\mathrm{a}_{4,2} = 3 \\ \mathrm{A}^{2}[3][3] &= \mathrm{a}_{3,1}\mathrm{a}_{1,3} + \mathrm{a}_{3,2}\mathrm{a}_{2,3} + \mathrm{a}_{3,3}\mathrm{a}_{3,3} + \mathrm{a}_{3,4}\mathrm{a}_{4,3} = 1 \\ \mathrm{A}^{2}[1][2] &= \mathrm{a}_{1,1}\mathrm{a}_{1,2} + \mathrm{a}_{1,2}\mathrm{a}_{2,2} + \mathrm{a}_{1,3}\mathrm{a}_{3,2} + \mathrm{a}_{1,4}\mathrm{a}_{4,2} = 0 \end{align*}
$$
  ![](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222161538625.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251222162816976.png)
### 三、邻接表法
- #### 邻接表法（顺序+链式存储）
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223150821085.png)
  ```c
  //用邻接表存储的图
  typedef struct
  {
	  AdjList vertices;
	  int vexnum,arcnum;
  }ALGraph;
  
  //"顶点"
  typedef struct VNode
  {
	  VertexType data;    //顶点信息
	  ArcNode *first;     //第一条边/弧
  }VNode,AdjList[MaxVertexNum];
  
  //"边/弧"
  typedef struct AcrNode
  {
	  int adjvex;          //边/弧指向哪个结点
	  struct ArcNode *next;//指向下一条弧的指针
	  //InfoType info;     //边权值
  }ArcNode;
  ```
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223151600471.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223151827265.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223151856556.png)
### 四、十字链表、邻接多重表
<div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223152130498.png" alt=""></div>


- #### 邻接矩阵、邻接表存储有向图
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223152439618.png)
- #### 十字链表存储有向图
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223152534581.png)
- #### 十字链表法性能分析
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223152914921.png)
- #### 邻接矩阵、邻接表存储无向图
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223153010382.png)
- #### 邻接多重表存储无向图
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223153055192.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223153240516.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251223153312517.png)
### 五、图的基本操作

![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224085331404.png)
- #### 图的基本操作
  - Adjacent(G,x,y)：判断图G是否存在边<x,y>或(x,y)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224085708727.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224090618639.png)
  - Neighbors(G,x)：列出图G中与结点x邻接的边
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224090417208.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224090539231.png)
  - InsertVertex(G,x)：在图G中插入顶点x
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224090804250.png)
  - DeleteVertex(G,x)：从G中删除顶点x
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224090936842.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224091114696.png)
  - AddEdge(G,x,y)：若无向边(x,y)或有向边<x,y>不存在，则向图G中添加该边
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224091536271.png)
  - RemoveEdge(G,x,y)：若无向边(x,y)或有向边<x,y>存在，则从图G中删除该边
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224091708040.png)
  - FirstNeighbor(G,x)：求图G中顶点x的第一个邻接点，若有则返回顶点号。若x没有邻接点或图中不存在x，则返回-1
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224091907731.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224091941486.png)
  - NextNeighbor(G,x,y)：假设图G中顶点y是顶点x的一个邻接点，返回除y之外顶点x的下一个邻接点的顶点号，若y是x的最后一个邻接点，则返回-1
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224092227150.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224092313191.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224103640129.png)
### 六、图的广度优先遍历
- #### 树 VS 图
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224135938527.png)
- #### 代码实现
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224140032382.png)
  ```c
  bool visited[MAX_VERTEX_NUM];        //访问标记数组
  
  //广度优先遍历
  void BFS(Graph G,int v){             //从顶点v出发，广度优先遍历图G
	  visit(v);                        //访问初始顶点v
	  visited[v] = TRUE;               //对v做已访问标记
	  Enqueue(Q,v);                    //顶点v入队列Q
	  while(!isEmpty(Q))
	  {
		  DeQueue(Q,v);                //顶点v出队列
		  for(w = FirstNeighbor(G,v);w >= 0;w = NextNeighbor(G,v,w))
		  {   //检测v所有邻接点
			  if(!visited[w])          //w为v的尚未访问的邻接顶点
			  {
				  visit(w);            //访问顶点w
				  visited[w] = TRUE    //对w做已访问标记
				  EnQueue(Q,w);        //顶点w入队列
			  }//if
		  }//for
	  }//while
  }
  ```
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224141415773.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224141514837.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224141554431.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224141622367.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224141656813.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224141730604.png)
  ......以此类推
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224141837904.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224141901592.png)
- #### 广度优先遍历序列
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224142046172.png)
- #### 遍历序列的可变性
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224142139532.png)
- #### 算法存在的问题
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224142244152.png)
- #### BFS算法（Final版）
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251224143550026.png)
  ```c
  bool visited[MAX_VERTEX_NUM];            //访问标记数组
  void BFSTraverse(Graph G){                //对图G进行广度优先遍历
	  for(i = 0;i < G.vexnum;++i)
		  visited[i] = FALSE;              //访问标记数组初始化
	  InitQueue(Q);                        //初始化辅助队列Q
	  for(i = 0;i < G.vexnum;++i)          //从0号顶点开始遍历
		  if(!visited[i])                  //对每个连通分量调用一次BFS
			  BFS(G,i);                    //vi未访问过，从vi开始BFS
  }
  //广度优先遍历
   void BFS(Graph G,int v){              //从顶点v出发，广度优先遍历图G 
	  visit(v);                        //访问出是顶点v
	  visited[v] = TRUE;               //对v做已访问标记
	  Enqueue(Q,v);                    //顶点v入队列Q
	  while(!isEmpty(Q))
	  {
		  DeQueue(Q,v);                //顶点v出队列
		  for(w = FirstNeighbor(G,v);w >= 0;w = NextNeighbor(G,v,w))
		  {   //检测v所有邻接点
			  if(!visited[w])          //w为v的尚未访问的邻接顶点
			  {
				  visit(w);            //访问顶点w
				  visited[w] = TRUE    //对w做已访问标记
				  EnQueue(Q,w);        //顶点w入队列
			  }//if
		  }//for
	  }//while
  }
  ```
- #### 复杂度分析
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251225091210446.png)
- #### 广度优先生成树
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251225143559573.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251225144132144.png)
- #### 广度优先生成森林
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251225144254470.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251225144315182.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251225150203652.png)
### 七、图的深度优先遍历
- #### 树的深度优先遍历
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226085803377.png)
- #### 图的深度优先遍历
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226085837457.png)
  ```c
  bool visited[MAX_VERTEX_NUM];            //访问标记数组
  
  void DFS(Graph G,int v){                 //从顶点v出发，深度优先遍历图G
	  visit(v);                            //访问顶点v
	  visited[v] = TRUE;                   //设已访问标记
	  for(w = FirstNeighbor(G,v);w >= 0;w = NextNeighbor(G,v,w))
		  if(!visited[w]){                 //w为u的尚未访问的邻接顶点
			  DFS(G,w);
		  }//if
  }
  ```
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090426589.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090518828.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090612675.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090651829.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090708553.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090746459.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090803742.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090845029.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090932658.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226090958776.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226091029911.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226091128064.png)
- #### 算法存在的问题
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226091240017.png)
- #### DFS算法（Final版）
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226091344796.png)
  ```c
  bool visited[MAX_VERTEX_NUM];            //访问标记数组
  
  void DFSTraverse(Graph G){               //对图G进行深度优先遍历
	  for(v = 0;v < G.vexnum;++v)
		  visited[v] = FALSE;              //初始化已访问标记数据
	  for(v = 0;v < G.vexnum;++v)          //本代码中是从v = 0开始遍历
		  if(!visited[v])
			  DFS(G,v);
  }
  
  void DFS(Graph G,int v){                 //从顶点v出发，深度优先遍历图G
	  visit(v);                            //访问顶点v
	  visited[v] = TRUE;                   //设已访问标记
	  for(w = FirstNeighbor(G,v);w >= 0;w = NextNeighbor(G,v,w))
		  if(!visited[w]){                 //w为u的尚未访问的邻接顶点
			  DFS(G,w);
		  }//if
  }
  ```
- #### 复杂度分析
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226092028434.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226092243983.png)
- #### 深度优先遍历序列
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226092558758.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226092646591.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226092722679.png)
- #### 深度优先生成树
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226092827826.png)
- #### 深度优先生成森林
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226093020560.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226093041555.png)

- #### 图的遍历与图的连通性
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226093149097.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226093224731.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226094325490.png)
### 八、最小生成树
- #### 生成树
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226094527205.png)
- #### 最小生成树（最小代价树）
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226094653442.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226094728804.png)
  对于一个==带权连通无向图==$G=(V,E)$，生成树不同，每棵树的权（即树中所有边上的权值之和）也可能不同。设$R$为$G$的所有生成树的集合，若T为R中==边的权值之和最小的生成树==，则$T$称为$G$的==最小生成树(*Minimum-Spanning-Tree,MST*)==。
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226095219944.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226095419969.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226095534674.png)
- #### Prim算法（普里姆）
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226095647609.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226095751652.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226095827492.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226095925787.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226095943179.png)
- #### Kruskal算法（克鲁斯卡尔）
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226100126536.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226100234750.png)
- #### Prim算法 VS Kruskal算法
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226100354333.png)
- #### Prim算法的实现思想
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226100510509.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226100708108.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226100921722.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101035512.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101103328.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101127901.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101203626.png)
- #### Kruskal算法的实现思想
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101359693.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101440503.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101505044.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101540675.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101629257.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101651716.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101804024.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101827922.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226101858047.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226102007693.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226102751186.png)
### 九、最短路径问题_BFS算法
- #### 最短路径问题
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226103321925.png)
- #### BFS求无权图的单源最短路径
  <div align="center"><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226103458935.png" alt=""><br><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226103656279.png" alt=""><br><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226103907103.png" alt=""><br><img src="https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226104045178.png" alt=""></div>

- #### 代码实现
  ```c
  bool visited[MAX_VERTEX_NUM];            //访问标记数组
  
    //广度优先遍历
  void BFS(Graph G,int v){             //从顶点v出发，广度优先遍历图G
	  visit(v);                        //访问初始顶点v
	  visited[v] = TRUE;               //对v做已访问标记
	  Enqueue(Q,v);                    //顶点v入队列Q
	  while(!isEmpty(Q))
	  {
		  DeQueue(Q,v);                //顶点v出队列
		  for(w = FirstNeighbor(G,v);w >= 0;w = NextNeighbor(G,v,w))
		  {   //检测v所有邻接点
			  if(!visited[w])          //w为v的尚未访问的邻接顶点
			  {
				  visit(w);            //访问顶点w
				  visited[w] = TRUE    //对w做已访问标记
				  EnQueue(Q,w);        //顶点w入队列
			  }//if
		  }//for
	  }//while
  }
  
  //求顶点u到其他顶点的最短路径
  void BFS_MIN_Distance(Graph G,int u){
	  //d[i]表示从u到i结点的最短路径
	  for(i = 0;i < G.vexnum;++i){
		  d[i] = ∞;                             //初始化路径长度
		  path[i] = -1;                         //最短路径从哪个顶点过来
	  }
	  d[u] = 0;
	  visited[u] = TRUE;
	  EnQueue(Q,u);
	  while(!isEmpty(Q)){                       //BFS算法主过程
		  DeQueue(Q,u);                         //队头元素u出队
		  for(w = FirstNeighbor(G,u);w >= 0;w = NextNeighbor(G,u,w))
			  if(!visited[w]){                  //w为u的尚未访问的邻接顶点
				  d[w] = d[u] + 1;              //路径长度加1
				  path[w] = u;                  //最短路径应从u到w
				  visited[w] = TRUE;            //设已访问标记
				  EnQueue(Q,w);                 //顶点w入队
			  }//if
	  }//while
  }
  ```
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226105451562.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226105738193.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226105841062.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226105924767.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226110035448.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226110154709.png)
  ![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226110304417.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226110422415.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251226110817072.png)
