### 树

### 一、树的定义和基本术语

- #### 树的基本概念

  ![image-20251209140553904](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209140553904.png)

  ==空树==——结点数为0的树

  ==非空树==的特性：

  有且仅有一个根结点

  没有后继的结点称为“叶子结点”（或终端结点）

  有后继的结点称为“分支节点”（或非终端结点）

  除了根结点外，任何一个结点都==有且仅有一个前驱==

  每个结点可以有0个或多个后继

  ![image-20251209141307610](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209141307610.png)

- #### 树形逻辑结构的应用

  ![image-20251209141636106](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209141636106.png)

- #### 结点之间的关系描述

  ![image-20251209142524888](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209142524888.png)

- #### 结点、树的属性描述

  ![image-20251209142808721](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209142808721.png)

  ![image-20251209142905720](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209142905720.png)

- #### 有序树V.S无序树

  ![image-20251209143058818](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209143058818.png)

- #### 树V.S森林

  ![image-20251209143230760](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209143230760.png)

  ![image-20251209144838234](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209144838234.png)

### 二、树的性质

- #### 树的常考性质

  ![image-20251209145053165](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209145053165.png)

  ![image-20251209145227940](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209145227940.png)

  ![image-20251209145330168](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209145330168.png)

  ![image-20251209145435758](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209145435758.png)

  ![image-20251209145630776](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209145630776.png)

  ![image-20251209145825854](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251209145825854.png)

### 三、二叉树的定义和基本术语

- #### 二叉树的概念

  ![image-20251210140326202](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210140326202.png)

- #### 二叉树的五种状态

  ![image-20251210140513646](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210140513646.png)

- #### 几个特殊的二叉树

  ![image-20251210141055396](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210141055396.png)

  ![image-20251210141239480](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210141239480.png)

  ![image-20251210141447139](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210141447139.png)

  ![image-20251210141609295](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210141609295.png)

  ![image-20251210141839623](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210141839623.png)

![image-20251210142416669](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210142416669.png)

### 四、二叉树的性质

- #### 二叉树的常考性质

  ![image-20251210142721748](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210142721748.png)

  ![image-20251210142754716](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210142754716.png)

  ![image-20251210142822064](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210142822064.png)

  ![image-20251210143018018](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210143018018.png)

  ![image-20251210143210973](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210143210973.png)

  ![image-20251210143441693](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210143441693.png)

![image-20251210144119696](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210144119696.png)

### 五、二叉树的存储结构

- #### 二叉树的顺序存储

  ![image-20251210144419747](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210144419747.png)

  ```c
  #define MaxSize 100
  
  struct TreeNode
  {
      ElemType value;    //结点中的数据元素
      bool isEmpty;      //结点是否为空
  };
  
  TreeNode t[MaxSize];
  ```

  ![image-20251210144809313](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210144809313.png)

  ![image-20251210144856915](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210144856915.png)

  ![image-20251210145035002](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210145035002.png)

  ![image-20251210145152971](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210145152971.png)

- #### 二叉树的链式存储

  ![image-20251210145338926](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210145338926.png)

  ```c
  struct ElemType
  {
      int value;
  };
  
  typedef struct BiTNode
  {
      ElemType data;
      struct BiTNode *lchild,*rchild;
  }BitNode,*BiTree;
  
  //定义一棵空树
  BiTree root = NULL;
  
  //插入根节点
  root = (BiTree)malloc(sizeof(BiTNode));
  root->data = {1};
  root->lchild = NULL;
  root->rchild = NULL;
  
  //插入新节点
  BiTNode * p = (BiTNode *)malloc(sizeof(BiTNode));
  p->data = {2};
  p->lchild = NULL;
  p->rchild = NULL;
  root->lchild = p;    //作为根节点的左孩子
  ```

  ![image-20251210150013155](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210150013155.png)

  ![image-20251210150229893](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210150229893.png)

![image-20251210151040325](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251210151040325.png)

### 六、二叉树的先/中/后序遍历

- #### 什么是遍历

  ![image-20251211142714100](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211142714100.png)

- #### 二叉树的遍历

  ![image-20251211142928070](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211142928070.png)

  ![image-20251211143330636](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211143330636.png)

  pre

![image-20251211143611892](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211143611892.png)

![image-20251211143827976](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211143827976.png)

- #### 先序遍历（代码）

  ```c
  typedef struct BiTNode
  {
      ElemType data;
      struct BiTNode *lchild,*rchild;
  }BiTNode,*BiTree;
  
  //先序遍历
  void PreOrder(BiTree T)
  {
      if(T != NULL)
      {
          visit(T);            //访问根结点
          PreOder(T->lchild);  //递归遍历左子树
          PreOder(T->rchild);  //递归遍历右子树
      }
  }
  ```

  ![image-20251211144417328](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211144417328.png)

- #### 中序遍历

  ```c
  typedef struct BiTNode
  {
      ElemType data;
      struct BiTNode *lchild,*rchild;
  }BiTNode,*BiTree;
  
  //先序遍历
  void PreOrder(BiTree T)
  {
      if(T != NULL)
      {
          PreOder(T->lchild);  //递归遍历左子树
          visit(T);            //访问根结点
          PreOder(T->rchild);  //递归遍历右子树
      }
  }
  ```

  ![image-20251211144557218](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211144557218.png)

- #### 后序遍历

  ```c
  typedef struct BiTNode
  {
      ElemType data;
      struct BiTNode *lchild,*rchild;
  }BiTNode,*BiTree;
  
  //先序遍历
  void PreOrder(BiTree T)
  {
      if(T != NULL)
      {
          PreOder(T->lchild);  //递归遍历左子树
          PreOder(T->rchild);  //递归遍历右子树
          visit(T);            //访问根结点
      }
  }
  ```

  ![image-20251211144711521](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211144711521.png)

![image-20251211145249719](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211145249719.png)

- #### 求先序遍历序列

  ![image-20251211145415577](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211145415577.png)

- #### 求中序遍历序列

  ![image-20251211145520633](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211145520633.png)

- #### 求后序遍历序列

  ![image-20251211145555943](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211145555943.png)

- #### 例：求树的深度（应用）

  ```c
  int treeDepth(BiTree T)
  {
      if(T == NULL)
      {
          return 0;
      }
      else
      {
          int l = treeDepth(T->lchild);
          int r = treeDrpth(T->rchild);
          //树的深度 = Max(左子树深度，右子树深度) + 1
          return l > r ? l + 1 : r + 1;
      }
  }
  ```

![image-20251211150620317](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211150620317.png)

### 七、二叉树的层序遍历

- #### 二叉树的层序遍历

  ![image-20251211150932828](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211150932828.png)

  ![image-20251211151045918](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211151045918.png)

  ![image-20251211151115652](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211151115652.png)

  ![image-20251211151142453](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211151142453.png)

  ![image-20251211151245897](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211151245897.png)

  ![image-20251211151325670](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211151325670.png)

  ![image-20251211151355040](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211151355040.png)

- #### 代码实现

  ```c
  //二叉树得结点（链式存储）
  typedef struct BiTNode
  {
      char data;
      struct BiTNode *lchild,*rchild;
  }BiTNode,*BiTree;
  
  //链式队列结点
  typedef struct LinkNode
  {
      BiTNode *data;          //存指针而不是结点
      struct LinkNode *next;
  }LinkNode;
  
  typedef struct
  {
      LinkNode *front,*rear;  //队头队尾
  }LinkQueue;
  
  //层序遍历
  void LevelOrder(BiTree T)
  {
      LinkQueue Q;
      InitQueue(Q);                    //初始化辅助队列
      BiTree p;
      EnQueue(Q,T);                    //将根结点入队
      while(!IsEmpty(Q))               //队列不空则循环
      {
          DeQueue(Q,p);                //对头结点出队
          visit(p);                    //访问出队结点
          if(p->lchild != NULL)
              EnQueue(Q,p->lchild);    //左孩子入队
          if(p->rchild != NULL)
              EnQueue(Q,p->rchild);    //右孩子入队
      }
  }
  ```

  ![image-20251211152402012](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211152402012.png)

![image-20251211153033522](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251211153033522.png)

### 八、由遍历序列构造二叉树

- #### 不同二叉树的中序遍历序列

  ![image-20251212133858778](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212133858778.png)

- #### 不同二叉树中的前序遍历序列

  ![image-20251212133950881](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212133950881.png)

- #### 不同二叉树中的后序遍历序列

  ![image-20251212134050904](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212134050904.png)

- #### 不同二叉树中的层序遍历序列

  ![image-20251212134132417](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212134132417.png)

- #### 由遍历序列构造二叉树

  ![image-20251212134227711](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212134227711.png)

- #### 前序+中序遍历序列

  ![image-20251212134347640](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212134347640.png)

  ##### 例1：

  ![image-20251212134551870](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212134551870.png)

  #####  例2：

  ![image-20251212134812532](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212134812532.png)

- #### 后序+中序遍历序列

  ![image-20251212134936480](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212134936480.png)

  ##### 例3：

  ![image-20251212135147843](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212135147843.png)

- #### 层序+中序遍历序列

  ![image-20251212135257520](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212135257520.png)

  ##### 例4：

  ![image-20251212135424050](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212135424050.png)

  ##### 例5：

  ![image-20251212135616819](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212135616819.png)

![image-20251212135655225](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212135655225.png)

![image-20251212140326699](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251212140326699.png)

### 九、线索二叉树的概念

- #### 二叉树的中序遍历序列

  ![image-20251215142005799](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215142005799.png)

  ![image-20251215142101511](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215142101511.png)

  ![image-20251215142137427](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215142137427.png)

- #### 中序线索二叉树

  ![image-20251215142431586](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215142431586.png)

  ![image-20251215142652033](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215142652033.png)

- #### 线索二叉树的存储结构

  ![image-20251215142852986](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215142852986.png)

- #### 中序线索二叉树的存储

  ![image-20251215143012360](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215143012360.png)

- #### 先序线索二叉树

  ![image-20251215143118047](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215143118047.png)

  ![image-20251215143154783](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215143154783.png)

- #### 后续线索二叉树

  ![image-20251215143313530](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215143313530.png)

  ![image-20251215143340365](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215143340365.png)

- #### 三种线索二叉树的对比

  ![image-20251215143437398](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215143437398.png)

![image-20251215144634140](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251215144634140.png)

### 十、在线索二叉树中找前驱后继

- #### 中序线索二叉树找中序后继

  ![image-20251216154528591](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216154528591.png)

  ```c
  //找到以p为根的子树，第一个被中序遍历的结点
  ThreadNode *Firstnode(ThreadNode *p)
  {
      //循环找到最左下结点（不一定是叶结点）
      while(p->ltag == 0)
          p = p->lchild;
      return p;
  }
  
  //在中序线索二叉树中找到结点p的后继结点
  ThreadNode *Nextnode(ThreadNode *p)
  {
      //右子树中最左下结点
      if(p->rtag == 0)
          return Firstnode(p->rchild);
      else
          return p->rchild;    //rtag == 1直接返回后继线索
  }
  
  //对中序线索二叉树进行中序遍历（利用线索实现的非递归算法[空间复杂度O(1)]）
  void Inorder(ThreadNode *T)
  {
      for(ThreadNode *p = Firstnode(T);p != NULL;p = Nextnode(p))
          visit(p);
  }
  ```

- #### 中序线索二叉树找中序前驱

  ![image-20251216160136862](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216160136862.png)

  ```c
  //找到以p为根的子树，最后一个被中序遍历的结点
  ThreadNode *Lastnode(ThreadNode *p)
  {
      //循环找到最右下结点（不一定是叶结点）
      while(p->rtag == 0)
          p = p->rchild;
      return p;
  }
  
  //在中序线索二叉树中找到结点p的前驱结点
  ThreadNode *Prenode(ThreadNode *p)
  {
      //左子树中最右下结点
      if(p->ltag == 0)
          return Lastnode(p->lchild);
      else
          return p->lchild;    //ltag == 1直接返回前驱线索
  }
  
  //对中序线索二叉树进行逆向中序遍历
  void RevInorder(Thread *T)
  {
      for(ThreadNode *p = Lastnode(T);p != NULL;p = Prenode(p))
          visit(p);
  }
  ```

- #### 先序线索二叉树找先序后继

  ![image-20251216161907433](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216161907433.png)

  ![image-20251216161930666](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216161930666.png)

  ![image-20251216162007605](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216162007605.png)

  ![image-20251216162118495](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216162118495.png)

  ![image-20251216162149917](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216162149917.png)

- #### 后序线索二叉树找后序前驱

  ![image-20251216162319973](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216162319973.png)

  ![image-20251216162347777](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216162347777.png)

  ![image-20251216162425559](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216162425559.png)

  ![image-20251216162523789](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216162523789.png)

![image-20251216164147320](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251216164147320.png)

### 十一、树的存储结构

- #### 树的存储1：双亲表示法（顺序存储）

  ![image-20251217093719175](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251217093719175.png)

  ```c
  #define MAX_TREE_SIZE 100
  typedef struct
  {
      ElemType data;
      int parent;
  }PTNode;
  
  typedef struct
  {
      PTNode notes[MAX_TREE_SIZE];
      int n,
  }PTree;
  ```

  ![image-20251217095910132](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251217095910132.png)
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218083316277.png)
- #### 树的存储2：孩子表示法
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218083739225.png)
  ```c
  struct CTNode
  {
	  int child;    //孩子结点在数组中的位置
	  struct CTNode *next;    //下一个孩子
  };
  
  typedef struct
  {
	  ElemType data;
	  struct CTNode *firstChild;    //第一个孩子
  }CTBox;
  
  typedef struct
  {
	  CTBox nodes[MAX_TREE_SIZE];
	  int n,r;    //结点数和根的位置
  }CTree;
  ```
![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218084351943.png)
![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218084633137.png)
![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218084957822.png)
- #### 树的存储3：孩子兄弟表示法
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218085443099.png)
  ```c
  //树的存储-孩子兄弟表示法
  typedef struct CSNode
  {
	  ElemType data;    //数据域
	  struct CSNode *firstchild,*nextsibling;    //第一个孩子和右兄弟指针
  }CSNode,*CSTree;
  
  //二叉树的结点（链式存储）
  typedef struct BiTNode
  {
	  ElemType data;
	  struct BiTNode *lchild,*rchild;
  }BiTNode,*BiTree;
  ```
 ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218090108036.png)
 ![](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218090220732.png)
![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218090927920.png)

### 十二、树、森林与二叉树的转换
- #### 树->二叉树的转换
	![](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218091354758.png)
- #### 森林->二叉树的转换
	![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218091753513.png)
- #### 二叉树->树的转换
	![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218092153551.png)
- #### 二叉树->森林的转换
	![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218092315678.png)
![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218093126464.png)
### 十三、树、森林的遍历
- #### 树的先根遍历
	![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218093741223.png)
	```c
		//树的先根遍历
		void PreOrder(TreeNode *R)
		{
			if (R != NULL)
			{
			visit(R);    //访问根节点
			while (R还有下一个子树T)
				PreOder(T);    //先根遍历下一棵子树
			}
		}
	```
- #### 树的后根遍历
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218094454688.png)
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218095107181.png)
  ```c
  //树的后根遍历
  void PostOrder(TreeNode *R)
  {
	  if (R != NULL)
	  {
	  while (R还有下一个子树T)
		  PostOrder(T);    //后根遍历下一棵子树
	  visit(R);    //访问根节点
	  }
  }
  ```
- #### 树的层次遍历
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218094901699.png)
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218095023143.png)
- #### 森林的先序遍历
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218095207698.png)
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218095245802.png)
- #### 森林的中序遍历
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218095333079.png)
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218095402881.png)
<div align="center"><img src= "https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218095733401.png" alt=""></div>

### 十四、哈夫曼树
- #### 带权路径长度
  1. 结点的==权==：有某种显示含义的数值（如：表示结点的重要性等）
  2. ==结点的带权路径长度==：从树的根到该结点的路径长度（经过的边数）与该结点上权值的乘积
  3. ==树的带权路径长度==：树中所有==叶结点==的带权路径长度之和（WPL,Weighted Path Length）
$$
\mathrm{WPL} = \sum_{i=1}^{n} w_{i} l_{i}
$$
- #### 哈夫曼树的定义
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218103212867.png)
- #### 哈夫曼树的构造
  给定*n*个权值分别为$w_{1},\dots,w_{n}$的结点，构造哈夫曼树的算法描述如下：
  1. 将这个*n*个结点分别作为*n*棵仅含一个结点的二叉树，构成森林*F*
  2. 构造一个新结点，从*F*中选取两棵结点权值最小的树作为新结点的左、右子树，并且将新结点的权值置为左、右子树上根结点的权值之和
  3. 从*F*中删除刚才选出的两棵树，同时将新得到的树加入*F*中
  4. 重复步骤1和3，直至*F*中只剩下一棵树为止

  ![150](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218104142778.png)![150](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218104228587.png)![150](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218104308455.png)![150](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218104341744.png)
  $$
\mathrm{WPL}_{min} = 1*7+2*3+3*2+4*1+4*2 = 31
$$
  1. 每个初始结点最终都成为叶结点，且权值越小的结点到根结点的路径长度越大
  2. 哈夫曼树的结点总数为*2n - 1*
  3. 哈夫曼树中不存在度为1的结点
  4. 哈夫曼树并不唯一，但WPL必然相同且为最优
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218105225763.png)
- #### 哈夫曼编码
  固定长度编码——每一个字符都用相等长度的二进制位表示
  <div align="center"><img src="https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218105416711.png" alt="" /></div>

  例：假设，100题中有80题选C，10题选A，8题选B，2题选D，所有答案的二进制长度为：$80*2+10*2+8*2+2*2 = 200 bit$
  <div align="center"><img src="https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218105713888.png" alt="" /></div>

  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218110651488.png)
  ==可变长度编码==——允许对不同字符用不等长的二进制位表示
  若没有一个编码是另一个编码的前缀，则称这样的编码为==前缀编码==
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218111211992.png)
  由哈夫曼树得到==哈夫曼编码==——字符集中的每个字符作为一个叶子结点，各个字符出现的频度作为结点的权值，根据之前介绍的方法构造哈夫曼树
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218111634494.png)

- #### 英文字母频次
  ![image.png](https://raw.githubusercontent.com/Ryokode/PicGo/main/20251218111729623.png)
![image.png](https://gitee.com/Ryokoi/picgo-typora/raw/master/20251218133339432.png)
![树.jpg](https://gitee.com/Ryokoi/picgo-typora/raw/master/树.jpg)
