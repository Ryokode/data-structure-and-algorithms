## 栈和队列的应用

### 一、栈在括号匹配中的应用

- #### 括号匹配问题

  ![image-20251127143937921](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127143937921.png)

  ![image-20251127144204379](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127144204379.png)

- #### 算法演示

  ![image-20251127144611174](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127144611174.png)

  ![image-20251127144821760](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127144821760.png)

  ```c
  #define MaxSize 10        //定义栈中元素的最大个数
  typedef struct
  {
      char data[MaxSize];   //静态数组存放栈中元素
      int top;              //栈顶指针
  }SqStack;
  
  //考试中可直接使用基本操作，建议简要说明接口
  //初始化栈
  void InitStack(SqStack &S);
  //判空
  bool StackEmpty(SqStack S);
  //新元素入栈
  bool Push(SqStack &S,char x);
  //栈顶元素出栈，用x返回
  bool Pop(SqStack &S,char &x);
  
  bool bracketCheck(char str[],int length)
  {
      SqStack S;
      InitStack(S);    //初始化一个栈
      
      for(int i = 0;i < length;i++)
      {
          if(str[i] == '(' || str[i] == '[' || str[i] == '{')
          {
              Push(S,str[i]);    //扫描到左括号，入栈
          }
          else
          {
              if(StackEmpty(S))    //扫描到右括号，且当前栈空
                  return false;    //匹配失败
              
              char topElem;
              Pop(S,topElem);      //栈顶元素出栈
              
              if(str[i] == ')' && topElem != '(')
                  return false;
              if(str[i] == ']' && topElem != '[')
                  return false;
              if(str[i] == '}' && topElem != '{')
                  return false;
          }
      }
      return StackEmpty(S);    //检索完全部括号后，栈空说明匹配成功
  }
  ```

  ![image-20251127150612437](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127150612437.png)

### 二、栈在表达式求值中的应用

![image-20251127152610995](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127152610995.png)

- #### 中缀、后缀、前缀表达式

  ![image-20251127153104173](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127153104173.png)

- #### 中缀表达式转后缀表达式（手算）

  ![image-20251127153457083](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127153457083.png)

  ![image-20251127153904021](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127153904021.png)

  ![image-20251127154116672](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127154116672.png)

- #### 后缀表达式的计算（手算）

  ![image-20251127154435182](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127154435182.png)

  ![image-20251127154632019](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127154632019.png)

- #### 后缀表达式的计算（机算）

  ![image-20251127155000064](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127155000064.png)

  ![image-20251127155034071](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127155034071.png)

  ![image-20251127155112076](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127155112076.png)

  ![image-20251127155141258](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127155141258.png)

  以此类推到最后

  ![image-20251127154929638](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127154929638.png)

  ![image-20251127155439989](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127155439989.png)

- #### 中缀表达式转前缀表达式（手算）

  ![image-20251127155846755](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127155846755.png)

  ![image-20251127155932149](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127155932149.png)

- #### 前缀表达式的计算

  ![image-20251127160046287](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251127160046287.png)

- #### 中缀表达式转后缀表达式（机算）

  ![image-20251128103003285](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251128103003285.png)

  ![image-20251128103336499](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251128103336499.png)

  ![image-20251128103528145](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251128103528145.png)

- #### 中缀表达式转后缀表达式（用栈实现）

  ![image-20251128103755716](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251128103755716.png)

  ![image-20251128104059712](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251128104059712.png)

  ![image-20251128104127792](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251128104127792.png)
  
  ![image-20251128142132833](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251128142132833.png)

![image-20251128142303510](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251128142303510.png)

![栈和队列的应用](https://gitee.com/Ryokoi/picgo-typora/raw/master/栈和队列的应用.jpg)

### 三、栈在递归中的应用

- #### 函数调用背后的过程

  ![image-20251201103845404](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251201103845404.png)

- #### 栈在递归中的应用

  ![image-20251201104019176](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251201104019176.png)

  ```c
  //Eg.1:递归算法求阶乘
  //计算正整数 n!
  int factorial(int n)
  {
      if(n == 0 || n == 1)
          return 1;
      else
          return n * factorial(n - 1);
  }
  
  int main()
  {
      //...其他代码
      int x = factorial(10);
      printf("加油！");
  }
  ```

  递归调用时，函数调用栈可称为“递归工作栈”

  每进入一层递归，就将递归调用所需信息压入栈顶

  每退出一层递归，就从栈顶弹出相应信息

  缺点：==太多层递归可能会导致栈溢出==

  可以自定义栈将递归算法改造为非递归算法

  ![image-20251201104841855](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251201104841855.png)

  ```c
  //Eg.2:递归算法求斐波那契数列
  int Fib(int n)
  {
      if(n == 0)
          return 0;
      else if(n == 1)
          return 1;
      else
          return Fib(n - 1) + Fib(n - 2);
  }
  
  int main()
  {
      //...其他代码
      int x = Fib(4);
      printf("加油！");
  }
  ```

  缺点：==可能包含很多重复计算==

  ![image-20251201105808970](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251201105808970.png)

  ![image-20251201110155066](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251201110155066.png)

  ![栈和队列的应用2](C:\Users\27154\Pictures\Camera Roll\栈和队列的应用2.jpg)

### 四、队列的应用

- #### 队列应用——树的层次遍历

  ![image-20251202144205443](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202144205443.png)

  刚开始1入队，然后从左往右2、3依次入队；再1出队，2对应的4、5从左往右依次入队；再2出队，3对应的6、7依次入队；再3出队...以此类推

- #### 队列应用——图的广度优先遍历

  ![image-20251202144735607](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202144735607.png)

  ![image-20251202145300981](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202145300981.png)

  和上面类似，处理1号结点入队，看与1号相连的有没有没有处理的结点；发现2、3是未处理的节点，2、3依次入队，1处理完出队；2有4未处理，4入队，2出队；3有5、6未处理，5、6依次入队，3出队；5有7、8未处理，7、8依次入队，5出队；6无未处理结点，6出队；7、8也无未处理节点，依次出队

- #### 队列在操作系统中的应用

  多个进程争抢着使用有限的系统资源时，==FCFS(First Come First Service,先来先服务)==<!--可用队列实现-->是一种常用策略

  ![image-20251202145716380](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202145716380.png)

  ![image-20251202145905725](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202145905725.png)

### 五、矩阵的压缩存储

- #### 一维数组的存储结构

  ![image-20251202150156715](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202150156715.png)

- #### 二维数组的存储结构

  ![image-20251202150338564](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202150338564.png)

  可实现随机存取

  ![image-20251202150504899](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202150504899.png)

  

![image-20251202150628898](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202150628898.png)

- #### 普通矩阵的存储

  ![image-20251202150831304](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202150831304.png)

- #### 对称矩阵的压缩存储

  ![image-20251202151055999](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202151055999.png)

  ![image-20251202151239263](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202151239263.png)

  ![image-20251202151400340](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202151400340.png)

  ![image-20251202151532484](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202151532484.png)

  ![image-20251202151658118](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202151658118.png)

  ![image-20251202151842209](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202151842209.png)

- #### 三角矩阵的压缩存储

  ![image-20251202151931790](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202151931790.png)

![image-20251202152055398](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202152055398.png)

![image-20251202152125221](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202152125221.png)

- #### 三对角矩阵的压缩存储

  ![image-20251202152401633](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202152401633.png)

  ![image-20251202152436865](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202152436865.png)

- #### 稀疏矩阵的压缩存储

  ![image-20251202152536281](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202152536281.png)

  ![image-20251202152628515](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251202152628515.png)

### 六、知识总结

![](https://gitee.com/Ryokoi/picgo-typora/raw/master/栈和队列的应用3.jpg)