## 单链表

- ### 单链表的定义

- ##### 什么是单链表

  ![image-20251118154711011](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251118154711011.png)

- ##### 用代码定义一个单链表

  ![image-20251118155420871](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251118155420871.png)

  ```c
  struct LNode             //定义单链表结点类型
  {
      ElemType data;       //每个节点存放一个数据元素
      struct LNode *next;  //指针指向下一个节点
  };
  
  //增加一个新结点：在内存中申请一个结点所需空间，并用指针p指向这个点
  struct LNode * p = (struct LNode *)malloc(sizeof(struct LNode));
  
  //用typedef重命名
  typedef struct LNode LNode;
  LNode * p = (LNode *)malloc(sizeof(LNode));
  
  //更简洁的方式举例
  typedef struct LNode
  {
      ElemType data;
      struct LNode *next;
  }LNode,*LinkList;           //将struct LNode重命名为LNode，并且用LinkList表示指向struct LNode的指针（下同）
  //上面代码等同于下面的代码
  struct LNode
  {
      ElemType data;
      struct LNode *next;
  };
  typedef struct LNode LNode;
  typedef struct LNode *LinkList;
  ```

  要表示一个单链表时，只需声明一个==头指针L==，指向单链表的第一个结点

  ```c
  LNode * L;    //声明一个指向单链表第一个结点的指针
  //或者下面的表示方法也一样
  LinkList L;   //声明一个指向单链表第一个结点的指针
  
  //e.q:
  LNode * GetElem(LinkList L,int i)
  {
      int j = 1;
      LNode *p = L->next;
      
      if(i == 0)
          return L;
      if(i < 1)
          return NULL;
      
      while(p != NULL && j < i)
      {
          p = p->next;
          j++;
      }
      return p;
  }
  ```

  强调这是一个单链表 使用LinkList

  强调这是一个结点使用LNode *

  但是这两种表达都是表示指向struct LNode的指针，只是强调的点不一样

  

- ##### 不带头结点的单链表

  ```c
  typedef struct LNode
  {
      ElemType data;
      struct LNode *next;
  }LNode,*LinkList;  
  
  //初始化一个空的单链表
  bool InitList(LinkList &L)
  {
      L = NULL;    //空表，暂时还没有任何结点，防止脏数据
      return true;
  }
  
  //判断单链表是否为空
  bool Empty(LinkList L)
  {
      if (L == NULL)
          return true;
      else
          return false;
  }
  //或者
  bool Empty(LinkList L)    //这个布尔函数的值本身就是TRUE或FLASE
  {
      return (L == NULL);    
  }
  
  void test()
  {
      LinkList L;    //注意，此处并没有创建一个结点
      //初始化一个空表
      InitList(L);
      //...后续代码...
  }
  ```

  ![image-20251118162858844](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251118162858844.png)

- ##### 带头结点的单链表

  ```c
  typedef struct LNode
  {
      ElemType data;
      struct LNode *next;
  }LNode,*LinkList;
  
  //初始化一个单链表（带头结点）
  bool InitList(LinkList &L)
  {
      L = (LNode *)malloc(sizeof(LNode));    //分配一个头结点
      
      if(L == NULL)
          return false;
      
      L->next = NULL;    //头结点之后暂时还没有结点
      return true;
  }
  
  //判断单链表是否为空（带头结点）
  bool Empty(LinkList L)
  {
      return (L->next == NULL);
  }
  
  void test()
  {
      LinkList L;    //注意，此处并没有创建一个结点
      //初始化一个空表
      InitList(L);
      //...后续代码...
  }
  ```

  ![image-20251118163638778](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251118163638778.png)

  ![image-20251118163756887](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251118163756887.png)
  
  
  
- ##### 知识总结

  ![image-20251118164936759](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251118164936759.png)



- ### 单链表的插入删除

- ##### 关于简化图的说明

  ![image-20251119091045972](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119091045972.png)

- ##### 按位序插入（带头结点）

  ListInsert(&L,i,e)：==插入==操作。在表L中的==第i个位置==<!--找到第i - 1个结点，将新结点插入其后-->上插入指定元素e。

  ![image-20251119092445757](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119092445757.png)

  ![image-20251119092717620](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119092717620.png)

  ```c
  //在第i个位置插入元素e（带头结点）
  
  typedef struct LNode
  {
      ElemType data;
      struct LNode *next;
  }LNode,*LinkList;
  
  bool ListInsert(LinkList &L,int i,ElemType e)
  {
      if(i < 1)
          return false;
      
      LNode *p;    //指针p指向当前扫描到的结点
      int j = 0;   //当前p指向的是第几个结点
      p = L;       //L指向头节点，头结点是第0个结点（不存数据）
       
      while(p != NULL && j < i - 1)    //循环找到i - 1个结点
      {
          p = p->next;
          j++;
      }
      
      if(p == NULL)    //i值不合法
          return false;
      
      LNode *s = (LNode *)malloc(sizeof(LNode));
      
      s->data = e;
      s->next = p->next;
      p->next = s;    //将结点s连到p之后
      return true;    //插入成功
  }
  //30和31不可颠倒！
  ```

  分析：

  1.如果i = 1（插在表头）

  ![image-20251119101536336](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119101536336.png)

  ![image-20251119101604115](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119101604115.png)

  ![image-20251119101648296](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119101648296.png)

  ![image-20251119100716414](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119100716414.png)

  最好的时间复杂度：O(1)

  若30和31颠倒则会导致断链：

  ![image-20251119101454164](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119101454164.png)

  2.如果i = 3（插在表中）

  ![image-20251119102109355](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119102109355.png)

  ![image-20251119102139682](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119102139682.png)

  ![image-20251119102400612](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119102400612.png)

  ![image-20251119102238747](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119102238747.png)

  3.如果i = 5（插在表尾）

  ![image-20251119102741557](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119102741557.png)

  ![image-20251119102803965](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119102803965.png)

  ![image-20251119102828684](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119102828684.png)

  ![image-20251119102858575](C:\Users\27154\AppData\Roaming\Typora\typora-user-images\image-20251119102858575.png)

  最坏的时间复杂度：O(n)

- ##### 按位序插入（不带头结点）

  ListInsert(&L,i,e)：==插入==操作。在表L中的==第i个位置==<!--找到第i - 1个结点，将新结点插入其后-->上插入指定元素e。

  ![image-20251119103556290](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119103556290.png)
  
  不存在“第0个”结点，因此i = 1时需要特殊处理
  
  ```c
  typedef struct LNode
  {
      ElemType data;
      struct LNode *next;
  }LNode,*LinkList;
  
  bool ListInsert(LinkList &L,int i,ElemType e)
  {
      if(i < 1)
          return false;
      if(i == 1)    //插入第1个结点的操作与其他结点操作不同
      {
          LNode *s = (LNode *)malloc(sizeof(LNode));
          s->data = e;
          s->next = L;
          L = s;              //头指针指向新结点
          return true;
      }
      
      LNode *p;    //指针p指向当前扫描的结点
      int j = 1;   //当前p指向的是第几个结点
      p = L;       //p指向第1个结点（注意：不是头结点）
      
      while(p != NULL && j < i - 1)  //循环找到第i - 1个结点
      {
          p = p->next;
          j++;
      }
      
      if(p == NULL)    //i值不合法
          reutnr false;
      
      LNode *s = (LNode *)malloc(sizeof(LNode));
      s->data = e;
      s->next = p->next;
      p->next = s;
      return true;    //插入成功
  }
  ```
  
  分析：
  
  1.如果i = 1（插在表头）
  
  ![image-20251119105051749](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119105051749.png)
  
  ![image-20251119105118308](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119105118308.png)
  
  ![image-20251119105239878](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119105239878.png)
  
  ![image-20251119105732768](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119105732768.png)
  
  

- ##### 指定结点的后插操作

  ```c
  //后插操作：在p结点之后插入元素e
  typedef struct LNode
  {
      ElemType data;
      struct LNode *next;
  }LNode,*LinkList;
  
  bool InsertNextNode(LNode *p,ElemType e)
  {
      if(p == NULL)        
          return false;
      
      LNode *s = (LNode *)malloc(sizeof(LNode));
      
      if(s == NULL)        //内存分配失败
          return false;
      
      s->data = e;         //用结点s保存数据元素e
      s->next = p->next;
      p->next = s;         //将结点s连到p之后
      return true;
  }
  ```

  ![image-20251119110705459](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119110705459.png)

  ![image-20251119110750959](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119110750959.png)

  ![image-20251119110816294](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119110816294.png)

  ![image-20251119110842980](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119110842980.png)

- 时间复杂度：O(1)

  ```c
  //在第i个位置插入元素e（带头结点）可更改为一下代码
  
  typedef struct LNode
  {
      ElemType data;
      struct LNode *next;
  }LNode,*LinkList;
  
  bool ListInsert(LinkList &L,int i,ElemType e)
  {
      if(i < 1)
          return false;
      
      LNode *p;    //指针p指向当前扫描到的结点
      int j = 0;   //当前p指向的是第几个结点
      p = L;       //L指向头节点，头结点是第0个结点（不存数据）
       
      while(p != NULL && j < i - 1)    //循环找到i - 1个结点
      {
          p = p->next;
          j++;
      }
      
     return InsertNextNode(p,e);
  }
  
  bool InsertNextNode(LNode *p,ElemType e)
  {
      if(p == NULL)        
          return false;
      
      LNode *s = (LNode *)malloc(sizeof(LNode));
      
      if(s == NULL)        //内存分配失败
          return false;
      
      s->data = e;         //用结点s保存数据元素e
      s->next = p->next;
      p->next = s;         //将结点s连到p之后
      return true;
  }
  ```

  

- ##### 指定节点的前插操作

  1.

  ```c
  //前程操作：在p结点前插入元素e
  bool InsertPrioNode(LinkList L,LNode *p,ElemType e)
  ```

  ![image-20251119140634530](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119140634530.png)

  2.

  ```c
  //前程操作：在p结点前插入元素e
  bool InsertPrioNode(LNode *p,ElemType e)
  {
      if(p == NULL)
          return false;
      
      LNode *s = (LNode *)malloc(sizeof(LNode));
      
      if(s == NULL)    //内存分配失败
          return false;
      
      s->next = p->next;
      p->next = s;        //新结点s连到p之后
      s->data = p->data;  //将p中元素复制到s中
      p->data = e;        //p中元素覆盖为e
      return true;
  }
  ```

  ![image-20251119141714302](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119141714302.png)

  ![image-20251119141735891](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119141735891.png)

  ![image-20251119141802526](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119141802526.png)

  ![image-20251119141837105](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119141837105.png)

  ![image-20251119141918083](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119141918083.png)

  时间复杂度为：O(1)

  ```c
  //前程操作：在p结点前插入元素s
  bool InsertPriorNode(LNode *p,LNode *s)
  {
      if(p == NULL || s == NULL)
          return false;
      
      s->next = p->next;
      p->next = s;              //s连到p之后
      ElemType temp = p->data;  //交换数据域部分
      p->data = s->data;
      s->data = temp;
      return true;
  }
  ```



- ##### 按位序删除（带头结点）

  ListDelete(&L,i,&e)：==删除==操作。删除表L中==第i个位置==<!--找到第i - 1个结点，将其指针指向第i + 1个结点，并释放第i个结点-->的元素，并用e返回删除元素的值。

  ![image-20251119143101962](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119143101962.png)

  ![image-20251119143331764](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119143331764.png)

  ![image-20251119143607617](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119143607617.png)

  free()释放第二个结点

  ```c
  typedef struct LNode
  {
      ElemType data;
      struct LNode *next;
  }LNode,*LinkList;
  
  bool ListDelete(LinkList &L,int i,ElemType &e)
  {
      if(i < 1)
          return false;
      
      LNode *p;        //指针p指向当前扫描到的结点
      int j = 0;       //当前p指向的是第几个结点
      p = L;           //L指向头结点，头结点是第0个结点（不存数据）
      
      while(p != NULL && j < i - 1)  //循环找到第i - 1个结点
      {
          p = p->next;
          j++;
      }
      
      if(p == NULL)        //i值不合法
          return false;
      
      if(p->next == NULL)  //第i - 1个结点之后无其他结点
          return false;
      
      LNode *q = p->next;  //令q指向被删除结点
      e = q->data;         //用e返回元素的值
      p->next = q->next;   //将*q结点从链中“断开”
      free(q);             //释放结点的存储空间
      return true;
  }
  ```

  ![image-20251119162042409](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119162042409.png)



- ##### 指定结点的删除

  ```c
  //删除指定结点p
  bool DeleteNode(LNode *p)
  {
      if(p == NULL)
          return false;
      
      LNode *q = p->next;      //令q指向*p的后继结点
      p->data = p->next->data; //和后继点交换数据域
      p->next = q->next;       //将*q结点从链中“断开”
      free(q);                 //释放后继结点的存储空间
      return true;
  }
  ```

  ![image-20251119164611462](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119164611462.png)

  ![image-20251119164752701](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119164752701.png)

- ##### 知识总结

  ![image-20251119165146132](https://gitee.com/Ryokoi/picgo-typora/raw/master/image-20251119165146132.png)